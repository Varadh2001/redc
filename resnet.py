# -*- coding: utf-8 -*-
"""resnet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yeqCGZbaC17pEo9QfBgjBzDkJOz4uojH
"""

#@title NETWORK
import torch.nn as nn

# Define the Residual Block with dilated convolution and LeakyReLU activation function
class ResidualBlock(nn.Module):
    def __init__(self, in_channels, out_channels):
        super(ResidualBlock, self).__init__()
        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=2, dilation=2)
        self.leaky_relu = nn.LeakyReLU(inplace=True, negative_slope=0.01)
        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=2, dilation=2)

    def forward(self, x):
        identity = x
        out = self.conv1(x)
        out = self.leaky_relu(out)
        out = self.conv2(out)
        out += identity
        out = self.leaky_relu(out)
        return out

# Define the ResNet architecture for Image Denoising with LeakyReLU activation function
class ResNet(nn.Module):
    def __init__(self, in_channels=1, out_channels=64, num_blocks=16):
        super(ResNet, self).__init__()
        self.conv = nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=2, dilation=2)
        self.leaky_relu = nn.LeakyReLU(inplace=True, negative_slope=0.01)
        self.res_blocks = self._make_res_blocks(out_channels, num_blocks)
        self.conv_out = nn.Conv2d(out_channels, in_channels, kernel_size=3, padding=2, dilation=2)

    def _make_res_blocks(self, channels, num_blocks):
        blocks = []
        for _ in range(num_blocks):
            blocks.append(ResidualBlock(channels, channels))
        return nn.Sequential(*blocks)

    def forward(self, x):
        identity = x
        out = self.conv(x)
        out = self.leaky_relu(out)
        out = self.res_blocks(out)
        out = self.conv_out(out)
        out += identity
        return out

# Create an instance of ResNet for Image Denoising with LeakyReLU activation function
in_channels = 1 # input image channels (e.g., 3 for RGB)
out_channels = 64 # number of channels in the ResNet blocks
num_blocks = 16 # number of ResNet blocks
resnet = ResNet(in_channels, out_channels, num_blocks)

# Print the ResNet architecture
print(resnet)